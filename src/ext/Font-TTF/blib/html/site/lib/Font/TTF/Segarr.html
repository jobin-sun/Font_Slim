<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#INSTANCE-VARIABLES">INSTANCE VARIABLES</a></li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#Font::TTF::Segarr-new-size">Font::TTF::Segarr-&gt;new($size)</a></li>
      <li><a href="#s-fastadd_segment-start-is_sparse-dat">$s-&gt;fastadd_segment($start, $is_sparse, @dat)</a></li>
      <li><a href="#s-add_segment-start-overwrite-dat">$s-&gt;add_segment($start, $overwrite, @dat)</a></li>
      <li><a href="#s-tidy">$s-&gt;tidy</a></li>
      <li><a href="#s-at-addr-len">$s-&gt;at($addr, [$len])</a></li>
      <li><a href="#s-remove-addr-len">$s-&gt;remove($addr, [$len])</a></li>
      <li><a href="#s-copy">$s-&gt;copy</a></li>
      <li><a href="#s-copy_seg-seg">$s-&gt;copy_seg($seg)</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Font::TTF::Segarr - Segmented array</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Holds data either directly or indirectly as a series of arrays. This class looks after the set of arrays and masks the individual sub-arrays, thus saving a class, we hope.</p>

<h1 id="INSTANCE-VARIABLES">INSTANCE VARIABLES</h1>

<p>All instance variables do not start with a space.</p>

<p>The segmented array is simply an array of segments</p>

<p>Each segment is a more complex affair:</p>

<dl>

<dt id="START">START</dt>
<dd>

<p>In terms of the array, the address for the 0th element in this segment.</p>

</dd>
<dt id="LEN">LEN</dt>
<dd>

<p>Number of elements in this segment</p>

</dd>
<dt id="VAL">VAL</dt>
<dd>

<p>The array which contains the elements</p>

</dd>
</dl>

<h1 id="METHODS">METHODS</h1>

<h2 id="Font::TTF::Segarr-new-size">Font::TTF::Segarr-&gt;new($size)</h2>

<p>Creates a new segmented array with a given data size</p>

<h2 id="s-fastadd_segment-start-is_sparse-dat">$s-&gt;fastadd_segment($start, $is_sparse, @dat)</h2>

<p>Creates a new segment and adds it to the array assuming no overlap between the new segment and any others in the array. $is_sparse indicates whether the passed in array contains <code>undef</code>s or not. If false no checking is done (which is faster, but riskier). If equal to 2 then 0 is considered undef as well.</p>

<p>Returns the number of segments inserted.</p>

<h2 id="s-add_segment-start-overwrite-dat">$s-&gt;add_segment($start, $overwrite, @dat)</h2>

<p>Creates a new segment and adds it to the array allowing for possible overlaps between the new segment and the existing ones. In the case of overlaps, elements from the new segment are deleted unless $overwrite is set in which case the elements already there are over-written.</p>

<p>This method also checks the data coming in to see if it is sparse (i.e. contains undef values). Gaps cause new segments to be created or not to over-write existing values.</p>

<h2 id="s-tidy">$s-&gt;tidy</h2>

<p>Merges any immediately adjacent segments</p>

<h2 id="s-at-addr-len">$s-&gt;at($addr, [$len])</h2>

<p>Looks up the data held at the given address by locating the appropriate segment etc. If $len &gt; 1 then returns an array of values, spaces being filled with undef.</p>

<h2 id="s-remove-addr-len">$s-&gt;remove($addr, [$len])</h2>

<p>Removes the item or items from addr returning them as an array or the first value in a scalar context. This is very like <code>at</code>, including padding with undef, but it deletes stuff as it goes.</p>

<h2 id="s-copy">$s-&gt;copy</h2>

<p>Deep copies this array</p>

<h2 id="s-copy_seg-seg">$s-&gt;copy_seg($seg)</h2>

<p>Creates a deep copy of a segment</p>

<h1 id="BUGS">BUGS</h1>

<p>No known bugs.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Martin Hosken Martin_Hosken@sil.org. See <a href="../../../../../Users/admin/Documents/philip-font-optimizer/ext/Font-TTF/blib/lib/Font/TTF/Font.html">Font::TTF::Font</a> for copyright and licensing.</p>


</body>

</html>


